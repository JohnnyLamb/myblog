{
  "generatedAt": "2026-02-01T05:24:10.007Z",
  "site": {
    "title": "J.A. Lamb",
    "description": "A minimal, readable publishing pipeline.",
    "url": "https://jlamb.dev"
  },
  "posts": [
    {
      "title": "Rolling my own static site generator",
      "date": "2026-02-01",
      "summary": "A small pipeline I can explain end to end.",
      "url": "https://jlamb.dev/posts/rolling-my-own-static-site-generator/",
      "path": "/posts/rolling-my-own-static-site-generator/",
      "slug": "rolling-my-own-static-site-generator",
      "content_html": "<p>I did not want a website product. I wanted a publishing pipeline I could understand in one sitting.</p>\n<p>The appeal was clarity: every step from Markdown to HTML is visible, and every file exists for a reason. There is no plugin marketplace to maintain, no theme layer to decode, and no magic I cannot explain later.</p>\n<p>Pipeline diagram:</p>\n<pre><code class=\"hljs\">src<span class=\"hljs-regexp\">/posts/</span>*.md\n  -&gt; frontmatter\n  -&gt; markdown -&gt; html\n  -&gt; layout wrap\n  -&gt; docs<span class=\"hljs-regexp\">/posts/</span>&lt;slug&gt;/index.html</code></pre><p>Tradeoffs I am accepting:</p>\n<ul>\n<li>No plugin ecosystem</li>\n<li>No one-click themes</li>\n<li>No auto-generated tag pages unless I build them</li>\n<li>No CMS integration out of the box</li>\n</ul>\n<p>That is fine. The system exists to serve the writing, not the other way around.</p>\n<p>Owning the pipeline changes how I write. The code is infrastructure—boring and reliable—and the writing is the only thing that should feel alive.</p>\n",
      "content_text": "I did not want a website product. I wanted a publishing pipeline I could understand in one sitting. The appeal was clarity: every step from Markdown to HTML is visible, and every file exists for a reason. There is no plugin marketplace to maintain, no theme layer to decode, and no magic I cannot explain later. Pipeline diagram: src /posts/ *.md -&gt; frontmatter -&gt; markdown -&gt; html -&gt; layout wrap -&gt; docs /posts/ &lt;slug&gt;/index.html Tradeoffs I am accepting: No plugin ecosystem No one-click themes No auto-generated tag pages unless I build them No CMS integration out of the box That is fine. The system exists to serve the writing, not the other way around. Owning the pipeline changes how I write. The code is infrastructure—boring and reliable—and the writing is the only thing that should feel alive."
    },
    {
      "title": "Building a back-of-the-envelope estimator",
      "date": "2026-01-31",
      "summary": "Sometimes copying what works is the right move.",
      "url": "https://jlamb.dev/posts/resource-estimator/",
      "path": "/posts/resource-estimator/",
      "slug": "resource-estimator",
      "content_html": "<p>I needed a resource estimator for system design calculations. Instead of inventing something, I studied what already worked.</p>\n<p>System Design School has a clean tool for this. Two columns: educational content on the left, calculator on the right. Reference tables at the bottom. No magic, just useful.</p>\n<p>The implementation took three files:</p>\n<pre><code class=\"hljs\">src<span class=\"hljs-regexp\">/lib/</span>estimator/calculations.ts   <span class=\"hljs-comment\"># Pure math</span>\nsrc<span class=\"hljs-regexp\">/components/</span>estimator/           <span class=\"hljs-comment\"># React component</span>\nsrc<span class=\"hljs-regexp\">/app/</span>tools<span class=\"hljs-regexp\">/estimator/</span>            <span class=\"hljs-comment\"># Route + layout</span></code></pre><p>The calculations file exports pure functions. No state, no side effects. Easy to test, easy to trust.</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">calculateEstimates</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">inputs</span>: <span class=\"hljs-title class_\">EstimatorInputs</span></span>): <span class=\"hljs-title class_\">EstimatorOutputs</span> {\n    <span class=\"hljs-keyword\">const</span> secondsPerDay = inputs.<span class=\"hljs-property\">precisionMode</span> ? <span class=\"hljs-number\">86_400</span> : <span class=\"hljs-number\">100_000</span>\n    <span class=\"hljs-keyword\">const</span> readsPerSecond = (inputs.<span class=\"hljs-property\">dau</span> * inputs.<span class=\"hljs-property\">readsPerUser</span>) / secondsPerDay\n    <span class=\"hljs-comment\">// ...</span>\n}</code></pre><p>The component handles inputs and renders outputs. The reference tables for image sizes, video bitrates, and storage latency are just static data. No API calls, no loading states.</p>\n<p>The hardest part was the layout. I wanted the tool to live at <code>/tools/estimator</code> but still show the same sidebar as the dashboard. That meant duplicating the layout logic, which felt wrong until I realized: consistency for the user matters more than DRY for the developer.</p>\n<p>The whole thing works offline. You can reason about it by reading the code. That is the feature.</p>\n",
      "content_text": "I needed a resource estimator for system design calculations. Instead of inventing something, I studied what already worked. System Design School has a clean tool for this. Two columns: educational content on the left, calculator on the right. Reference tables at the bottom. No magic, just useful. The implementation took three files: src /lib/ estimator/calculations.ts # Pure math src /components/ estimator/ # React component src /app/ tools /estimator/ # Route + layout The calculations file exports pure functions. No state, no side effects. Easy to test, easy to trust. export function calculateEstimates ( inputs : EstimatorInputs ): EstimatorOutputs { const secondsPerDay = inputs. precisionMode ? 86_400 : 100_000 const readsPerSecond = (inputs. dau * inputs. readsPerUser ) / secondsPerDay // ... } The component handles inputs and renders outputs. The reference tables for image sizes, video bitrates, and storage latency are just static data. No API calls, no loading states. The hardest part was the layout. I wanted the tool to live at /tools/estimator but still show the same sidebar as the dashboard. That meant duplicating the layout logic, which felt wrong until I realized: consistency for the user matters more than DRY for the developer. The whole thing works offline. You can reason about it by reading the code. That is the feature."
    },
    {
      "title": "Integrating GSD into the agent API layer",
      "date": "2026-01-30",
      "summary": "The protocol that makes agents finish what they start.",
      "url": "https://jlamb.dev/posts/gsd-agent-integration/",
      "path": "/posts/gsd-agent-integration/",
      "slug": "gsd-agent-integration",
      "content_html": "<p>Agents loop. They read files, think about reading more files, then read the same files again. Without structure, they wander.</p>\n<p>GSD (Get Shit Done) is a protocol. It gives the agent phases: GATHER, IMPLEMENT, VERIFY, COMPLETE. Each phase has one job. Do the job, update state, move on.</p>\n<p>The key insight was XML tasks. Instead of free-form reasoning, the agent generates structured plans:</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">task</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span>Create user model<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">name</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span>&gt;</span>Write src/models/user.ts with id, email, createdAt fields<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">action</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">verify</span>&gt;</span>File exists and exports User type<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">verify</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">done</span>&gt;</span>User model created<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">done</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">task</span>&gt;</span></code></pre><p>Each task is atomic. The agent executes one, verifies it worked, then moves to the next. No backtracking, no infinite loops.</p>\n<p>The integration required two functions: <code>planLoop()</code> generates the XML tasks from requirements. <code>executeLoop()</code> runs them sequentially with verification.</p>\n<p>The agent now finishes what it starts. That is the whole point of GSD.</p>\n",
      "content_text": "Agents loop. They read files, think about reading more files, then read the same files again. Without structure, they wander. GSD (Get Shit Done) is a protocol. It gives the agent phases: GATHER, IMPLEMENT, VERIFY, COMPLETE. Each phase has one job. Do the job, update state, move on. The key insight was XML tasks. Instead of free-form reasoning, the agent generates structured plans: &lt; task &gt; &lt; name &gt; Create user model &lt;/ name &gt; &lt; action &gt; Write src/models/user.ts with id, email, createdAt fields &lt;/ action &gt; &lt; verify &gt; File exists and exports User type &lt;/ verify &gt; &lt; done &gt; User model created &lt;/ done &gt; &lt;/ task &gt; Each task is atomic. The agent executes one, verifies it worked, then moves to the next. No backtracking, no infinite loops. The integration required two functions: planLoop() generates the XML tasks from requirements. executeLoop() runs them sequentially with verification. The agent now finishes what it starts. That is the whole point of GSD."
    },
    {
      "title": "The agent that pushes to GitHub",
      "date": "2026-01-28",
      "summary": "Code generation is easy. Deployment is the test.",
      "url": "https://jlamb.dev/posts/agent-github-push/",
      "path": "/posts/agent-github-push/",
      "slug": "agent-github-push",
      "content_html": "<p>Everyone demos code generation. Few ship it.</p>\n<p>The agent runs in a Docker sandbox. It clones a repo, makes changes, commits, and pushes. Real git operations, real authentication, real consequences.</p>\n<p>The tricky part was GitHub App authentication. Installation tokens expire. The sandbox needs fresh credentials each run. The solution was generating tokens on demand:</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">const</span> { token } = <span class=\"hljs-keyword\">await</span> octokit.<span class=\"hljs-property\">rest</span>.<span class=\"hljs-property\">apps</span>.<span class=\"hljs-title function_\">createInstallationAccessToken</span>({\n    <span class=\"hljs-attr\">installation_id</span>: installationId\n})\n<span class=\"hljs-keyword\">const</span> cloneUrl = <span class=\"hljs-string\">`https://x-access-token:<span class=\"hljs-subst\">${token}</span>@github.com/<span class=\"hljs-subst\">${repo}</span>.git`</span></code></pre><p>The sandbox clones with the token URL, does its work, and pushes. No SSH keys to manage, no stored credentials. The token lives only as long as the agent needs it.</p>\n<p>Now the agent&#39;s output lands in a real repository. You can review it, merge it, or reject it. That feedback loop is what makes the whole system useful.</p>\n",
      "content_text": "Everyone demos code generation. Few ship it. The agent runs in a Docker sandbox. It clones a repo, makes changes, commits, and pushes. Real git operations, real authentication, real consequences. The tricky part was GitHub App authentication. Installation tokens expire. The sandbox needs fresh credentials each run. The solution was generating tokens on demand: const { token } = await octokit. rest . apps . createInstallationAccessToken ({ installation_id : installationId }) const cloneUrl = `https://x-access-token: ${token} @github.com/ ${repo} .git` The sandbox clones with the token URL, does its work, and pushes. No SSH keys to manage, no stored credentials. The token lives only as long as the agent needs it. Now the agent&#39;s output lands in a real repository. You can review it, merge it, or reject it. That feedback loop is what makes the whole system useful."
    },
    {
      "title": "Deploying PRD bundles to GitHub",
      "date": "2026-01-25",
      "summary": "Requirements become code through a pipeline you can trace.",
      "url": "https://jlamb.dev/posts/prd-bundle-deploy/",
      "path": "/posts/prd-bundle-deploy/",
      "slug": "prd-bundle-deploy",
      "content_html": "<p>A PRD bundle is a package. It contains the product requirements, the technical context, and the acceptance criteria. Everything the agent needs to implement a feature.</p>\n<p>When a PRD gets approved, it triggers deployment. The bundle gets serialized to JSON and committed to the target repository. The agent picks it up from there.</p>\n<p>The flow is intentionally simple:</p>\n<ol>\n<li>Human writes PRD in the UI</li>\n<li>Human approves the PRD</li>\n<li>System bundles PRD + context + criteria</li>\n<li>Bundle deploys to GitHub as a commit</li>\n<li>Agent reads bundle and implements</li>\n</ol>\n<p>Each step is visible. You can inspect the bundle before the agent touches it. You can see exactly what context it received.</p>\n<p>This traceability is the feature. When something goes wrong, you can ask: was the PRD unclear, or did the agent misinterpret it? The bundle is the evidence.</p>\n",
      "content_text": "A PRD bundle is a package. It contains the product requirements, the technical context, and the acceptance criteria. Everything the agent needs to implement a feature. When a PRD gets approved, it triggers deployment. The bundle gets serialized to JSON and committed to the target repository. The agent picks it up from there. The flow is intentionally simple: Human writes PRD in the UI Human approves the PRD System bundles PRD + context + criteria Bundle deploys to GitHub as a commit Agent reads bundle and implements Each step is visible. You can inspect the bundle before the agent touches it. You can see exactly what context it received. This traceability is the feature. When something goes wrong, you can ask: was the PRD unclear, or did the agent misinterpret it? The bundle is the evidence."
    },
    {
      "title": "Dream Machine begins",
      "date": "2026-01-20",
      "summary": "Building the infrastructure for AI-assisted development.",
      "url": "https://jlamb.dev/posts/dream-machine-begins/",
      "path": "/posts/dream-machine-begins/",
      "slug": "dream-machine-begins",
      "content_html": "<p>Dream Machine started as a question: what if you could describe what you want and have an agent build it?</p>\n<p>Not a chatbot that suggests code. Not an autocomplete that guesses your next line. A system that takes requirements, reasons about them, and produces working software.</p>\n<p>The initial commit was infrastructure. Next.js for the UI. Prisma for the database. Docker for sandboxing. GitHub Apps for authentication.</p>\n<p>Each choice was about control. Next.js because it runs anywhere. Prisma because migrations are explicit. Docker because agents need isolation. GitHub Apps because installation-level access beats personal tokens.</p>\n<p>Phase 4 was making the pieces talk to each other. The UI creates PRDs. The backend packages them. The sandbox runs agents. GitHub receives the output.</p>\n<p>The dream is simple: describe the machine you want, then watch it get built. The infrastructure is what makes that possible.</p>\n",
      "content_text": "Dream Machine started as a question: what if you could describe what you want and have an agent build it? Not a chatbot that suggests code. Not an autocomplete that guesses your next line. A system that takes requirements, reasons about them, and produces working software. The initial commit was infrastructure. Next.js for the UI. Prisma for the database. Docker for sandboxing. GitHub Apps for authentication. Each choice was about control. Next.js because it runs anywhere. Prisma because migrations are explicit. Docker because agents need isolation. GitHub Apps because installation-level access beats personal tokens. Phase 4 was making the pieces talk to each other. The UI creates PRDs. The backend packages them. The sandbox runs agents. GitHub receives the output. The dream is simple: describe the machine you want, then watch it get built. The infrastructure is what makes that possible."
    },
    {
      "title": "Why static is still enough",
      "date": "2026-01-15",
      "summary": "The simplest pipeline is the one you can explain.",
      "url": "https://jlamb.dev/posts/why-static/",
      "path": "/posts/why-static/",
      "slug": "why-static",
      "content_html": "<p>Static sites are not a nostalgia act. They are a refusal to let the tool decide the shape of your thinking.</p>\n<p>When you can trace every step from a Markdown file to a deployed page, you can trust the system. That is the whole point.</p>\n",
      "content_text": "Static sites are not a nostalgia act. They are a refusal to let the tool decide the shape of your thinking. When you can trace every step from a Markdown file to a deployed page, you can trust the system. That is the whole point."
    }
  ]
}
